%  Copyright (C) 2002-2004 David Roundy
%
%  This program is free software; you can redistribute it and/or modify
%  it under the terms of the GNU General Public License as published by
%  the Free Software Foundation; either version 2, or (at your option)
%  any later version.
%
%  This program is distributed in the hope that it will be useful,
%  but WITHOUT ANY WARRANTY; without even the implied warranty of
%  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%  GNU General Public License for more details.
%
%  You should have received a copy of the GNU General Public License
%  along with this program; see the file COPYING.  If not, write to
%  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
%  Boston, MA 02110-1301, USA.

\begin{code}
{-# OPTIONS_GHC -cpp #-}
{-# LANGUAGE CPP #-}

#include "gadts.h"

module Grit.Arguments ( GritFlag( .. ), flagToString, optionFlags,
                         isin, arein,
                         fixFilePathOrStd, fixFilePathOrUrl, fixUrl,
                         fixSubPaths, areFileArgs,
                         GritOption( .. ), option_from_darcsoption,
                         help, list_options,
                         max_count, help_on_match,
                         any_verbosity, disable,
                         notest, test, working_repo_dir,
                         testByDefault,
                         remote_repo, lazy,
                         possibly_remote_repo_dir, get_repourl,
                         author, get_sendmail_cmd,
                         patchname_option, distname_option,
                         logfile, rmlogfile, from_opt, subject, get_subject,
                         in_reply_to, get_in_reply_to,
                         target, cc, get_cc, output, output_auto_name,
                         recursive, inventory_choices, get_inventory_choices,
                         ask_long_comment, sendmail_cmd,
                         sign, verify, edit_description,
                         reponame, creatorhash,
                         apply_conflict_options, reply,
                         pull_conflict_options, use_external_merge,
                         deps_sel, nocompress,
                         uncompress_nocompress, repo_combinator,
                         options_latex, reorder_patches,
                         noskip_boring, allow_problematic_filenames,
                         show_autogenerated,
                         applyas, human_readable,
                         changes_reverse, only_to_files,
                         changes_format, match_one_nontag,
                         pipe_interactive, all_interactive,
                         all_pipe_interactive,
                         summary, unified, tokens,
                         diff_cmd_flag, diffflags, unidiff, xmloutput,
                         force_replace, match_one, match_several, match_range,
                         match_several_or_range,
                         match_several_or_last,
                         set_default,
                         pristine_tree,
                         sibling, flagsToSiblings, relink, nolinks,
                         files, directories, pending,
                         posthook_cmd, get_posthook_cmd,
                         prehook_cmd, get_prehook_cmd, nullFlag,
                         patch_select_flag,
                         allow_unrelated_repos
                      ) where
import System.Console.GetOpt
import Data.List ( nub )
import Data.Maybe ( fromMaybe, catMaybes )
import Control.Monad ( unless )
import Data.Char ( isDigit )

import Grit.Utils ( maybeGetEnv, firstJustIO, withCurrentDirectory )
import Grit.URL ( is_file )
import Grit.RepoPath ( AbsolutePath, AbsolutePathOrStd, SubPath,
                        AbsoluteOrRemotePath, ioAbsoluteOrRemote, toFilePath,
                        makeSubPathOf, simpleSubPath,
                        ioAbsolute, ioAbsoluteOrStd,
                        makeAbsolute, makeAbsoluteOrStd )
import Grit.Flags ( GritFlag(..) )
#include "impossible.h"
\end{code}

\begin{code}
data FlagContent = NoContent | AbsoluteContent AbsolutePath | AbsoluteOrStdContent AbsolutePathOrStd | StringContent String
                   deriving (Eq, Show, Ord)

-- getContent is very tedious to write, but this is the only way (that
-- I know of) to guarantee that it works for all flags (which then
-- guarantees that isAnAbsolute, isa, flagToString, etc also work
-- properly)

-- | 'get_content' returns the content of a flag, if any.
-- For instance, the content of @Author \"Louis Aragon\"@ is @StringContent
-- \"Louis Aragon\"@, while the content of @Pipe@ is @NoContent@
getContent :: GritFlag -> FlagContent
getContent (PatchName s) = StringContent s
getContent (Output s) = AbsoluteOrStdContent s
getContent Verbose = NoContent
getContent Help = NoContent
getContent ListOptions = NoContent
getContent Test = NoContent
getContent NoTest = NoContent
getContent TagOnTest = NoContent
getContent NoTagOnTest = NoContent
getContent HelpOnMatch = NoContent
getContent OnlyChangesToFiles = NoContent
getContent LeaveTestDir = NoContent
getContent NoLeaveTestDir = NoContent
getContent Timings = NoContent
getContent Debug = NoContent
getContent DebugVerbose = NoContent
getContent DebugHTTP = NoContent
getContent NormalVerbosity = NoContent
getContent Quiet = NoContent
getContent (Target s) = StringContent s
getContent (Cc s) = StringContent s
getContent (Subject s) = StringContent s
getContent (InReplyTo s) = StringContent s
getContent (SendmailCmd s) = StringContent s
getContent (Author s) = StringContent s
getContent (OnePatch s) = StringContent s
getContent (SeveralPatch s) = StringContent s
getContent (AfterPatch s) = StringContent s
getContent (UpToPatch s) = StringContent s
getContent (TagName s) = StringContent s
getContent (LastN s) = StringContent (show s)
getContent (MaxC s) = StringContent (show s)
getContent (OneTag s) = StringContent s
getContent (AfterTag s) = StringContent s
getContent (UpToTag s) = StringContent s
getContent (LogFile s) = AbsoluteContent s
getContent (OutputAutoName s) = AbsoluteContent s
getContent NumberPatches = NoContent
getContent (PatchIndexRange _ _) = NoContent -- FIXME this doesn't fit into a neat category
getContent Count = NoContent
getContent All = NoContent
getContent Recursive = NoContent
getContent NoRecursive = NoContent
getContent Reorder = NoContent
getContent RestrictPaths = NoContent
getContent DontRestrictPaths = NoContent
getContent AskDeps = NoContent
getContent NoAskDeps = NoContent
getContent RmLogFile = NoContent
getContent (DistName s) = StringContent s
getContent (CreatorHash s) = StringContent s
getContent (SignAs s) = StringContent s
getContent (SignSSL s) = StringContent s
getContent (Verify s) = AbsoluteContent s
getContent (VerifySSL s) = AbsoluteContent s
getContent IgnoreTimes = NoContent
getContent LookForAdds = NoContent
getContent NoLookForAdds = NoContent
getContent AnyOrder = NoContent
getContent Intersection = NoContent
getContent Unified = NoContent
getContent Union = NoContent
getContent Complement = NoContent
getContent Sign = NoContent
getContent NoSign = NoContent
getContent HappyForwarding = NoContent
getContent (Toks s) = StringContent s
getContent (WorkDir s) = StringContent s
getContent (RepoDir s) = StringContent s
getContent (RemoteRepo s) = StringContent s
getContent (Reply s) = StringContent s
getContent EditDescription = NoContent
getContent NoEditDescription = NoContent
getContent EditLongComment = NoContent
getContent NoEditLongComment = NoContent
getContent PromptLongComment = NoContent
getContent AllowConflicts = NoContent
getContent MarkConflicts = NoContent
getContent NoAllowConflicts = NoContent
getContent Boring = NoContent
getContent HideAutogenerated = NoContent
getContent ShowAutogenerated = NoContent
getContent AllowCaseOnly = NoContent
getContent AllowWindowsReserved = NoContent
getContent DontGrabDeps = NoContent
getContent DontPromptForDependencies = NoContent
getContent PromptForDependencies = NoContent
getContent Compress = NoContent
getContent NoCompress = NoContent
getContent UnCompress = NoContent
getContent MachineReadable = NoContent
getContent HumanReadable = NoContent
getContent Pipe = NoContent
getContent Interactive = NoContent
getContent Summary = NoContent
getContent NoSummary = NoContent
getContent (ApplyAs s) = StringContent s
getContent (DiffCmd s) = StringContent s
getContent (ExternalMerge s) = StringContent s
getContent (DiffFlags s) = StringContent s
getContent Reverse = NoContent
getContent Complete = NoContent
getContent Lazy = NoContent
getContent Ephemeral = NoContent
getContent (FixFilePath _ _) = NoContent -- FIXME!!!
getContent XMLOutput = NoContent
getContent ForceReplace = NoContent
getContent NonApply = NoContent
getContent NonVerify = NoContent
getContent NonForce = NoContent
getContent DryRun = NoContent
getContent SetDefault = NoContent
getContent NoSetDefault = NoContent
getContent FancyMoveAdd = NoContent
getContent NoFancyMoveAdd = NoContent
getContent Disable = NoContent
getContent UseHashedInventory = NoContent
getContent UseOldFashionedInventory = NoContent
getContent UseFormat2 = NoContent
getContent PristinePlain = NoContent
getContent PristineNone = NoContent
getContent NoUpdateWorking = NoContent
getContent Relink = NoContent
getContent NoLinks = NoContent
getContent Files = NoContent
getContent NoFiles = NoContent
getContent Directories = NoContent
getContent NoDirectories = NoContent
getContent Pending = NoContent
getContent NoPending = NoContent
getContent NoPosthook = NoContent
getContent (Sibling s) = AbsoluteContent s
getContent (PosthookCmd s) = StringContent s
getContent NoPrehook = NoContent
getContent StoreInMemory = NoContent
getContent HTTPPipelining = NoContent
getContent NoHTTPPipelining = NoContent
getContent NoCache = NoContent
getContent NullFlag = NoContent
getContent (PrehookCmd s) = StringContent s
getContent (UMask s) = StringContent s
getContent AllowUnrelatedRepos = NoContent

get_content :: GritFlag -> Maybe String
get_content f = do StringContent s <- Just $ getContent f
                   return s

-- | @a `'isa'` b@ tests whether @a@ is flag @b@ with a string argument.
-- @b@ typically is a Flag constructor expecting a string
-- For example, @(Author \"Ted Hughes\") `isa` Author@ returns true.
isa :: GritFlag -> (String -> GritFlag) -> Bool
a `isa` b = case get_content a of
            Nothing -> False
            Just s -> a == b s

-- | @a `'isAnAbsolute'` b@ tests whether @a@ is flag @b@ with an absolute path argument.
-- @b@ typically is a Flag constructor expecting an absolute path argument
-- For example, @(Context contextfile) `isAnAbsolute` Context@ returns true.
isAnAbsolute :: GritFlag -> (AbsolutePath -> GritFlag) -> Bool
isAnAbsolute f x = case getContent f of
                  AbsoluteContent s -> f == x s
                  _ -> False

-- | @a `'isAnAbsoluteOrStd'` b@ tests whether @a@ is flag @b@ with a path argument.
-- @b@ typically is a Flag constructor expecting a path argument
-- For example, @(Output o) `isAnAbsoluteOrStd` @ returns true.
isAnAbsoluteOrStd :: GritFlag -> (AbsolutePathOrStd -> GritFlag) -> Bool
isAnAbsoluteOrStd f x = case getContent f of
                          AbsoluteOrStdContent s -> f == x s
                          _ -> False

isin :: (String->GritFlag) -> [GritFlag] -> Bool
f `isin` fs = any (`isa` f) fs

arein :: [GritOption] -> [GritFlag] -> Bool
(GritNoArgOption _ _ f _ : dos') `arein` fs
    = f `elem` fs || dos' `arein` fs
(GritArgOption _ _ f _ _ : dos') `arein` fs
    = f `isin` fs || dos' `arein` fs
(GritAbsPathOption _ _ f _ _ : dos') `arein` fs
    = any (`isAnAbsolute` f) fs || dos' `arein` fs
(GritAbsPathOrStdOption _ _ f _ _ : dos') `arein` fs
    = any (`isAnAbsoluteOrStd` f) fs || dos' `arein` fs
(GritOptAbsPathOption _ _ _ f _ _ : dos') `arein` fs
    = any (`isAnAbsolute` f) fs || dos' `arein` fs
(GritMultipleChoiceOption os: dos') `arein` fs
    = os `arein` fs || dos' `arein` fs
[] `arein` _ = False

-- | A type for darcs' options. The value contains the command line
-- switch(es) for the option, a help string, and a function to build a
-- @GritFlag@ from the command line arguments.  for each constructor,
-- 'shortSwitches' represents the list of short command line switches
-- which invoke the option, longSwitches the list of long command line
-- switches, optDescr the description of the option, and argDescr the description
-- of its argument, if any. mkFlag is a function which makes a @GritFlag@ from
-- the arguments of the option.
data GritOption
    = GritArgOption [Char] [String] (String->GritFlag) String String
    -- ^ @GritArgOption shortSwitches longSwitches mkFlag ArgDescr OptDescr@
    -- The constructor for options with a string argument, such as
    -- @--tag@

    | GritAbsPathOption [Char] [String] (AbsolutePath -> GritFlag) String String
    -- ^ @GritAbsPathOption shortSwitches longSwitches mkFlag ArgDescr OptDescr@
    -- The constructor for options with an absolute path argument, such as
    -- @--sibling@

    | GritAbsPathOrStdOption [Char] [String] (AbsolutePathOrStd -> GritFlag) String String
    -- ^ @GritAbsPathOrStdOption shortSwitches longSwitches mkFlag ArgDescr OptDescr@
    -- The constructor for options with a path argument, such as @-o@

    | GritOptAbsPathOption [Char] [String] String (AbsolutePath -> GritFlag) String String
    -- ^ @GritOptAbsPathOrStdOption shortSwitches longSwitches defaultPath
    -- mkFlag ArgDescr OptDescr@ where defaultPath is a default value
    -- for the Path, as a string to be parsed as if it had been given
    -- on the command line.
    -- The constructor for options with an optional path argument, such as @-O@

    | GritNoArgOption [Char] [String] GritFlag String
    -- ^ @GritNoArgOption shortSwitches longSwitches mkFlag optDescr@
    -- The constructon fon options with no arguments.

    | GritMultipleChoiceOption [GritOption]
    -- ^ A constructor for grouping related options together, such as
    -- @--hashed@, @--darcs-2@ and @--old-fashioned-inventory@.

optionFlags :: GritOption -> [String]
optionFlags (GritArgOption _ fs _ _ _) = fs
optionFlags (GritAbsPathOption _ fs _ _ _) = fs
optionFlags (GritAbsPathOrStdOption _ fs _ _ _) = fs
optionFlags (GritOptAbsPathOption _ fs _ _ _ _) = fs
optionFlags (GritNoArgOption _ fs _ _) = fs
optionFlags (GritMultipleChoiceOption os) = concatMap optionFlags os

option_from_darcsoption :: AbsolutePath -> GritOption -> [OptDescr GritFlag]
option_from_darcsoption _ (GritNoArgOption a b c h) = [Option a b (NoArg c) h]
option_from_darcsoption _ (GritArgOption a b c n h) = [Option a b (ReqArg c n) h]
option_from_darcsoption wd (GritMultipleChoiceOption os) = concatMap (option_from_darcsoption wd) os
option_from_darcsoption wd (GritAbsPathOrStdOption a b c n h) = [Option a b (ReqArg (c . makeAbsoluteOrStd wd) n) h]
option_from_darcsoption wd (GritAbsPathOption a b c n h) = [Option a b (ReqArg (c . makeAbsolute wd) n) h]
option_from_darcsoption wd (GritOptAbsPathOption a b d c n h) = [Option a b (OptArg (c . makeAbsolute wd . fromMaybe d) n) h]

-- | 'concat_option' creates a GritMultipleChoiceOption from a list of
-- option, flattening any GritMultipleChoiceOption in the list.
concat_options :: [GritOption] -> GritOption
concat_options os = GritMultipleChoiceOption $ concatMap from_option os
 where
  from_option (GritMultipleChoiceOption xs) = xs
  from_option x = [x]
\end{code}

\begin{code}
extract_fix_path :: [GritFlag] -> Maybe (AbsolutePath, AbsolutePath)
extract_fix_path [] = Nothing
extract_fix_path ((FixFilePath repo orig):_)  = Just (repo, orig)
extract_fix_path (_:fs) = extract_fix_path fs

fixFilePath :: [GritFlag] -> FilePath -> IO AbsolutePath
fixFilePath opts f = case extract_fix_path opts of
                       Nothing -> bug "Can't fix path in fixFilePath"
                       Just (_,o) -> withCurrentDirectory o $ ioAbsolute f

fixFilePathOrStd :: [GritFlag] -> FilePath -> IO AbsolutePathOrStd
fixFilePathOrStd opts f =
    case extract_fix_path opts of
      Nothing -> bug "Can't fix path in fixFilePathOrStd"
      Just (_,o) -> withCurrentDirectory o $ ioAbsoluteOrStd f

fixFilePathOrUrl :: [GritFlag] -> String -> IO AbsoluteOrRemotePath
fixFilePathOrUrl opts f =
    case extract_fix_path opts of
      Nothing -> bug "Can't fix path in fixFilePathOrUrl"
      Just (_,o) -> withCurrentDirectory o $ ioAbsoluteOrRemote f

fixUrl :: [GritFlag] -> String -> IO String
fixUrl opts f = if is_file f
                then toFilePath `fmap` fixFilePath opts f
                else return f

fixSubPaths :: [GritFlag] -> [FilePath] -> IO [SubPath]
fixSubPaths flags fs =
    withCurrentDirectory o $
    do fixedfs <- mapM fixit $ filter (not.null) fs
       let (good, bad) = partitionEither fixedfs
       unless (null bad) $
              putStrLn $ "Ignoring non-repository paths: " ++ unwords bad
       return $ nub good
 where
    (r,o) = case extract_fix_path flags of
            Just xxx -> xxx
            Nothing -> bug "Can't fix path in fixSubPaths"
    fixit p = do ap <- ioAbsolute p
                 case makeSubPathOf r ap of
                   Just sp -> return $ Right sp
                   Nothing -> return $ maybe (Left p) Right $ simpleSubPath p

partitionEither :: [Either a b] -> ([b],[a])
partitionEither es = ( [b | Right b <- es]
                     , [a | Left  a <- es] )

-- as opposed to just '.'
areFileArgs :: [SubPath] -> Bool
areFileArgs rps = concatMap toFilePath rps /= ""
\end{code}

\begin{code}
-- | 'list_option' is an option which lists the command's arguments
list_options :: GritOption
list_options = GritNoArgOption [] ["list-options"] ListOptions
               "simply list the command's arguments"

flagToString :: [GritOption] -> GritFlag -> Maybe String
flagToString x f = maybeHead $ catMaybes $ map f2o x
    where f2o (GritArgOption _ (s:_) c _ _) = do arg <- get_content f
                                                 if c arg == f
                                                      then return $ unwords [('-':'-':s), arg]
                                                      else Nothing
          f2o (GritNoArgOption _ (s:_) f' _) | f == f' = Just ('-':'-':s)
          f2o (GritMultipleChoiceOption xs) = maybeHead $ catMaybes $ map f2o xs
          f2o _ = Nothing
          maybeHead (a:_) = Just a
          maybeHead [] = Nothing

reponame :: GritOption
deps_sel :: GritOption
tokens :: GritOption
working_repo_dir :: GritOption
possibly_remote_repo_dir :: GritOption
disable :: GritOption

pipe_interactive, all_pipe_interactive, all_interactive, all_patches, interactive, pipe,
  human_readable, diffflags, allow_problematic_filenames, noskip_boring,
  ask_long_comment, match_one_nontag, changes_reverse, creatorhash,
  changes_format,
  diff_cmd_flag, use_external_merge,
  pull_conflict_options, target, cc, apply_conflict_options, reply, xmloutput,
  distname_option, patchname_option, edit_description,
  output, output_auto_name, unidiff, repo_combinator,
  unified, summary, uncompress_nocompress, subject, in_reply_to,
  nocompress, match_several_or_range, match_several_or_last,
  author, help, force_replace,
  help_on_match, allow_unrelated_repos,
  match_one, match_range, match_several, sendmail_cmd,
  logfile, rmlogfile, from_opt, set_default, pristine_tree

      :: GritOption

recursive :: String -> GritOption

sign, applyas, verify :: GritOption
\end{code}

\section{Common options to darcs commands}

\begin{options}
--help
\end{options}
Every \verb|COMMAND| accepts \verb!--help! as an argument, which tells it to
provide a bit of help.  Among other things, this help always provides an
accurate listing of the options available with that command, and is
guaranteed never to be out of sync with the version of darcs you actually
have installed (unlike this manual, which could be for an entirely
different version of darcs).
\begin{verbatim}
% darcs COMMAND --help
\end{verbatim}
\begin{code}
help = GritNoArgOption ['h'] ["help"] Help
       "shows brief description of command and its arguments"

help_on_match = GritNoArgOption [] ["match"] HelpOnMatch
       "shows a summary of how to use patch matching rules"
\end{code}

\begin{options}
--disable
\end{options}
Every {\tt COMMAND} accepts the \verb!--disable! option, which can be used in
\verb!.arcs-prefs/defaults! to disable some commands in the repository. This
can be helpful if you want to protect the repository from accidental use of
advanced commands like obliterate, unpull, unrecord or amend-record.
\begin{code}
disable = GritNoArgOption [] ["disable"] Disable
        "disable this command"
\end{code}

\begin{options}
--verbose, --quiet, --normal-verbosity
\end{options}
Most commands also accept the \verb!--verbose! option, which tells darcs to
provide additional output.  The amount of verbosity varies from command to
command.  Commands that accept \verb!--verbose\verb! also accept \verb!--quiet\verb!,
which surpresses non-error output, and \verb!--normal-verbosity\verb! which can be
used to restore the default verbosity if \verb!--verbose! or \verb!--quiet! is in
the defaults file.

\begin{options}
--debug, --debug-http
\end{options}
Many commands also accept the \verb!--debug! option, which causes darcs to generate
additional output that may be useful for debugging its behavior, but which otherwise
would not be interesting. Option \verb!--debug-http! makes darcs output debugging
info for curl and libwww.
\begin{code}
any_verbosity :: [GritOption]
any_verbosity =[GritMultipleChoiceOption
                [GritNoArgOption [] ["debug"] Debug
                 "give only debug output",
                 GritNoArgOption [] ["debug-verbose"] DebugVerbose
                 "give debug and verbose output",
                 GritNoArgOption [] ["debug-http"] DebugHTTP
                 "give debug output for curl and libwww",
                 GritNoArgOption ['v'] ["verbose"] Verbose
                 "give verbose output",
                 GritNoArgOption ['q'] ["quiet"] Quiet
                 "suppress informational output",
                 GritNoArgOption [] ["standard-verbosity"] NormalVerbosity
                 "neither verbose nor quiet output"],
                 GritNoArgOption [] ["timings"] Timings "provide debugging timings information"]
\end{code}

\begin{options}
--repodir
\end{options}
Another common option is the \verb!--repodir! option, which allows you to
specify the directory of the repository in which to perform the command.
This option is used with commands, such as whatsnew, that ordinarily would
be performed within a repository directory, and allows you to use those
commands without actually being in the repository directory when calling the
command.  This is useful when running darcs in a pipe, as might be the case
when running \verb'apply' from a mailer.

\begin{code}
working_repo_dir = GritArgOption [] ["repodir"] WorkDir "DIRECTORY"
             "specify the repository directory in which to run"
possibly_remote_repo_dir = GritArgOption [] ["repo"] RepoDir "URL"
             "specify the repository URL"

-- | 'get_repourl' takes a list of flags and returns the url of the
-- repository specified by @Repodir \"directory\"@ in that list of flags, if any.
-- This flag is present if darcs was invoked with @--repodir=DIRECTORY@
get_repourl :: [GritFlag] -> Maybe String
get_repourl [] = Nothing
get_repourl (RepoDir d:_) | not (is_file d) = Just d
get_repourl (_:fs) = get_repourl fs
\end{code}

\begin{options}
--remote-repo
\end{options}

Some commands, such as \verb'pull' require a remote repository to be specified,
either from the command line or as a default.  The \verb!--remote-repo!
provides an alternative way to supply this remote repository path.  This flag
can be seen as temporarily ``replacing'' the default repository. Setting it
causes the command to ignore the default repository (it also does not affect,
i.e. overwrite the default repository).  On the other hand, if any other
repositories are supplied as command line arguments, this flag will be ignored
(and the default repository may be overwritten).

\begin{code}
-- | 'remote_repo' is the option used to specify the URL of the remote
-- repository to work with
remote_repo :: GritOption
remote_repo = GritArgOption [] ["remote-repo"] RemoteRepo "URL"
             "specify the remote repository URL to work with"
\end{code}

\input{Grit/Match.lhs}
\input{Grit/PatchMatch.lhs}

\begin{code}
patchname_option = GritArgOption ['m'] ["patch-name"] PatchName "PATCHNAME"
                   "name of patch"

match_one = concat_options [__patch, __tag, __index]
match_one_nontag = concat_options [__patch, __index]
match_several    = concat_options [__patches, __tags]
match_range            = concat_options [match_to, match_from, __patch, __last, __indexes]
match_several_or_range = concat_options [match_to, match_from, __last, __indexes,
                                         __patches, __tags]
match_several_or_last  = concat_options [match_from, __last, __patches, __tags]

match_to, match_from :: GritOption
match_to = GritMultipleChoiceOption
            [GritArgOption [] ["to-patch"] UpToPatch "REGEXP"
             "select changes up to a patch matching REGEXP",
             GritArgOption [] ["to-tag"] UpToTag "REGEXP"
             "select changes up to a tag matching REGEXP"]
match_from = GritMultipleChoiceOption
              [GritArgOption [] ["from-patch"] AfterPatch "REGEXP"
               "select changes starting with a patch matching REGEXP",
               GritArgOption [] ["from-tag"] AfterTag "REGEXP"
               "select changes starting with a tag matching REGEXP"]

__tag, __tags, __patch, __patches, __last, __index, __indexes :: GritOption

__tag = GritArgOption ['t'] ["tag"] OneTag "REGEXP"
       "select tag matching REGEXP"
__tags = GritArgOption ['t'] ["tags"] OneTag "REGEXP"
        "select tags matching REGEXP"

__patch = GritArgOption ['p'] ["patch"] OnePatch "REGEXP"
         "select a single patch matching REGEXP"
__patches = GritArgOption ['p'] ["patches"] SeveralPatch "REGEXP"
           "select patches matching REGEXP"

__last = GritArgOption [] ["last"] lastn "NUMBER"
         "select the last NUMBER patches"
    where lastn s = if and (map isDigit s)
                    then LastN (read s)
                    else LastN (-1)

max_count :: GritOption
max_count = GritArgOption [] ["max-count"] maxc "NUMBER"
         "limit the number of patches displayed"
    where maxc s = if and (map isDigit s)
                   then MaxC (read s)
                   else MaxC (-1)

__index = GritArgOption ['n'] ["index"] indexrange "N-M" "select a range of patches"
    where indexrange s = if all isDigit s
                         then PatchIndexRange (read s) (read s)
                         else PatchIndexRange 0 0

__indexes = GritArgOption ['n'] ["index"] indexrange "N-M" "select a range of patches"
    where indexrange s = if all isokay s
                         then if '-' `elem` s
                              then let x1 = takeWhile (/= '-') s
                                       x2 = reverse $ takeWhile (/= '-') $ reverse s
                                   in PatchIndexRange (read x1) (read x2)
                              else PatchIndexRange (read s) (read s)
                         else PatchIndexRange 0 0
          isokay c = isDigit c || c == '-'
\end{code}

\begin{options}
--test, --no-test
\end{options}

If you like, you can configure your repository to be able to run a test
suite of some sort.  You can do this by using ``setpref'' to set the
``test'' value to be a command to run, e.g.
\begin{verbatim}
% darcs setpref test "sh configure && make && make test"
\end{verbatim}
Or, if you want to define a test specific to one copy of the repository,
you could do this by editing the file \verb!.arcs-prefs/prefs!.

\begin{options}
--leave-test-directory, --remove-test-directory
\end{options}

Normally darcs deletes the directory in which the test was run afterwards.
Sometimes (especially when the test fails) you'd prefer to be able to be
able to examine the test directory after the test is run.  You can do this
by specifying the \verb!--leave-test-directory! flag.  Alas, there is no
way to make darcs leave the test directory only if the test fails.  The
opposite of \verb!--leave-test-directory! is
\verb!--remove-test-directory!, which could come in handy if you choose to
make \verb!--leave-test-directory! the default (see
section~\ref{defaults}).

\begin{code}
test, notest :: [GritOption]
notest = [GritMultipleChoiceOption
          [GritNoArgOption [] ["no-test"] NoTest "don't run the test script",
           GritNoArgOption [] ["test"] Test "run the test script"],
          leave_test_dir, tag_on_test]
test = [GritMultipleChoiceOption
        [GritNoArgOption [] ["test"] Test "run the test script",
         GritNoArgOption [] ["no-test"] NoTest "don't run the test script"],
        leave_test_dir, tag_on_test]
leave_test_dir :: GritOption
leave_test_dir = GritMultipleChoiceOption
                 [GritNoArgOption [] ["leave-test-directory"]
                  LeaveTestDir "don't remove the test directory",
                  GritNoArgOption [] ["remove-test-directory"]
                  NoLeaveTestDir "remove the test directory"]
tag_on_test :: GritOption
tag_on_test = GritMultipleChoiceOption
              [GritNoArgOption [] ["tag-on-test"]
               TagOnTest "tag version when test is passed",
               GritNoArgOption [] ["no-tag-on-test"]
               NoTagOnTest "don't tag version when test is passed [DEFAULT]"]

testByDefault :: [GritFlag] -> [GritFlag]
testByDefault o = if NoTest `elem` o then o else Test:o

pristine_tree =
    GritMultipleChoiceOption
    [GritNoArgOption [] ["plain-pristine-tree"] PristinePlain
     "use a plain pristine tree [DEFAULT]",
     GritNoArgOption [] ["no-pristine-tree"] PristineNone
     "use no pristine tree"]

ask_long_comment =
    GritMultipleChoiceOption
    [GritNoArgOption [] ["edit-long-comment"] EditLongComment
     "edit the long comment by default",
     GritNoArgOption [] ["skip-long-comment"] NoEditLongComment
     "don't give a long comment",
     GritNoArgOption [] ["prompt-long-comment"] PromptLongComment
     "prompt for whether to edit the long comment"]
\end{code}

\begin{options}
--author
\end{options}
\label{env:DARCS_EMAIL}
Several commands need to be able to identify you.  Conventionally, you
provide an email address for this purpose, which can include comments,
e.g.\ \verb!David Roundy <droundy@abridgegame.org>!.  The easiest way to do
this is
to define an environment variable \verb!EMAIL! or \verb!DARCS_EMAIL! (with
the latter overriding the former).  You can also override this using the
\verb!--author! flag to any command.  Alternatively, you could set your
email address on a per-repository basis using the ``defaults'' mechanism
for ``ALL'' commands, as described in Appendix~\ref{repository_format}.
Or, you could specify the author on a per-repository basis using the
\verb!.arcs-prefs/author! file as described in section~\ref{author_prefs}.

Also, a global author file can be created in your home directory with the name
\verb!.darcs/author!.  This file overrides the
contents of the environment variables, but a repository-specific author
file overrides the global author file.

\begin{code}
logfile = GritAbsPathOption [] ["logfile"] LogFile "FILE"
          "give patch name and comment in file"

rmlogfile = GritNoArgOption [] ["delete-logfile"] RmLogFile
            "delete the logfile when done"

author = GritArgOption ['A'] ["author"] Author "EMAIL" "specify author id"
from_opt = GritArgOption [] ["from"] Author "EMAIL" "specify email address"

\end{code}

\begin{options}
--dont-compress, --compress
\end{options}
By default, darcs commands that write patches to disk will compress the
patch files.  If you don't want this, you can choose the
\verb!--dont-compress! option, which causes darcs not to compress the patch
file.

\begin{code}
nocompress = concat_options [__compress, __dont_compress]
uncompress_nocompress = concat_options [__compress, __dont_compress, __uncompress]

__compress, __dont_compress, __uncompress :: GritOption
__compress = GritNoArgOption [] ["compress"] Compress
            "create compressed patches"
__dont_compress = GritNoArgOption [] ["dont-compress"] NoCompress
                  "don't create compressed patches"
__uncompress = GritNoArgOption [] ["uncompress"] UnCompress
               "uncompress patches"
\end{code}

\begin{code}
summary = GritMultipleChoiceOption
          [GritNoArgOption ['s'] ["summary"] Summary "summarize changes",
           GritNoArgOption [] ["no-summary"] NoSummary "don't summarize changes"]
unified = GritNoArgOption ['u'] ["unified"] Unified
          "output patch in a darcs-specific format similar to diff -u"
unidiff = GritNoArgOption ['u'] ["unified"] Unified
          "pass -u option to diff"
diff_cmd_flag = GritArgOption [] ["diff-command"]
       DiffCmd "COMMAND" "specify diff command (ignores --diff-opts)"
\end{code}

\begin{code}
target = GritArgOption [] ["to"] Target "EMAIL" "specify destination email"
cc = GritArgOption [] ["cc"] Cc "EMAIL" "mail results to additional EMAIL(s). Requires --reply"

-- |'get_cc' takes a list of flags and returns the addresses to send a copy of
-- the patch bundle to when using @darcs send@.
-- looks for a cc address specified by @Cc \"address\"@ in that list of flags.
-- Returns the addresses as a comma separated string.
get_cc :: [GritFlag] -> String
get_cc fs = lt $ catMaybes $ map whatcc fs
            where whatcc (Cc t) = Just t
                  whatcc _ = Nothing
                  lt [t] = t
                  lt [t,""] = t
                  lt (t:ts) = t++" , "++lt ts
                  lt [] = ""
\end{code}

\begin{code}
subject = GritArgOption [] ["subject"] Subject "SUBJECT" "specify mail subject"

-- |'get_subject' takes a list of flags and returns the subject of the mail
-- to be sent by @darcs send@. Looks for a subject specified by
-- @Subject \"subject\"@ in that list of flags, if any.
-- This flag is present if darcs was invoked with @--subject=SUBJECT@
get_subject :: [GritFlag] -> Maybe String
get_subject (Subject s:_) = Just s
get_subject (_:fs) = get_subject fs
get_subject [] = Nothing
\end{code}

\begin{code}
in_reply_to = GritArgOption [] ["in-reply-to"] InReplyTo "EMAIL" "specify in-reply-to header"
get_in_reply_to :: [GritFlag] -> Maybe String
get_in_reply_to (InReplyTo s:_) = Just s
get_in_reply_to (_:fs) = get_in_reply_to fs
get_in_reply_to [] = Nothing
\end{code}

\begin{code}
output = GritAbsPathOrStdOption ['o'] ["output"] Output "FILE"
         "specify output filename"
\end{code}

\begin{code}
output_auto_name = GritOptAbsPathOption ['O'] ["output-auto-name"] "." OutputAutoName "DIRECTORY"
                   "output to automatically named file in DIRECTORY, default: current directory"
\end{code}

\begin{code}
edit_description =
    GritMultipleChoiceOption
    [GritNoArgOption [] ["edit-description"] EditDescription
                          "edit the patch bundle description",
     GritNoArgOption [] ["dont-edit-description"] NoEditDescription
                      "don't edit the patch bundle description"]
\end{code}

\begin{code}
distname_option = GritArgOption ['d'] ["dist-name"] DistName "DISTNAME"
                  "name of version"
\end{code}

\begin{code}
recursive h
    = GritMultipleChoiceOption
      [GritNoArgOption ['r'] ["recursive"] Recursive h,
       GritNoArgOption [] ["not-recursive"] NoRecursive ("don't "++h)]
\end{code}

\begin{code}
inventory_choices :: GritOption
inventory_choices =
    GritMultipleChoiceOption
    [GritNoArgOption [] ["hashed"] UseHashedInventory
                          "Some new features. Compatible with older repos",
     GritNoArgOption [] ["darcs-2"] UseFormat2
                          "All features. Related repos must use same format [DEFAULT]",
     GritNoArgOption [] ["old-fashioned-inventory"] UseOldFashionedInventory
                          "Minimal features. What older repos use."]

get_inventory_choices :: GritOption
get_inventory_choices =
    GritMultipleChoiceOption
    [GritNoArgOption [] ["hashed"] UseHashedInventory
                          "Convert darcs-1 format to hashed format",
     GritNoArgOption [] ["old-fashioned-inventory"] UseOldFashionedInventory
                          "Convert from hashed to darcs-1 format"]
\end{code}

\begin{code}
xmloutput = GritNoArgOption [] ["xml-output"] XMLOutput
        "generate XML formatted output"
\end{code}

\begin{code}
creatorhash = GritArgOption [] ["creator-hash"] CreatorHash "HASH"
              "specify hash of creator patch (see docs)"
\end{code}

\begin{code}
sign = GritMultipleChoiceOption
       [GritNoArgOption [] ["sign"] Sign
        "sign the patch with your gpg key",
        GritArgOption [] ["sign-as"] SignAs "KEYID"
        "sign the patch with a given keyid",
        GritArgOption [] ["sign-ssl"] SignSSL "IDFILE"
        "sign the patch using openssl with a given private key",
        GritNoArgOption [] ["dont-sign"] NoSign
        "don't sign the patch"]
applyas = GritMultipleChoiceOption
           [GritArgOption [] ["apply-as"] ApplyAs "USERNAME"
            "apply patch as another user using sudo",
            GritNoArgOption [] ["apply-as-myself"] NonApply
            "don't use sudo to apply as another user [DEFAULT]"]
set_default = GritMultipleChoiceOption
              [GritNoArgOption [] ["set-default"] SetDefault
               "set default repository [DEFAULT]",
               GritNoArgOption [] ["no-set-default"] NoSetDefault
               "don't set default repository"]
\end{code}

\begin{code}
verify = GritMultipleChoiceOption
         [GritAbsPathOption [] ["verify"] Verify "PUBRING"
          "verify that the patch was signed by a key in PUBRING",
          GritAbsPathOption [] ["verify-ssl"] VerifySSL "KEYS"
          "verify using openSSL with authorized keys from file KEYS",
          GritNoArgOption [] ["no-verify"] NonVerify
          "don't verify patch signature"]
\end{code}

\begin{code}
reponame = GritArgOption [] ["repo-name"] WorkDir "DIRECTORY"
           "path of output directory"
deps_sel = GritMultipleChoiceOption
       [GritNoArgOption [] ["no-deps"] DontGrabDeps
        "don't automatically fulfill dependencies",
        GritNoArgOption [] ["dont-prompt-for-dependencies"] DontPromptForDependencies
        "don't ask about patches that are depended on by matched patches (with --match or --patch)",
        GritNoArgOption [] ["prompt-for-dependencies"] PromptForDependencies
        "prompt about patches that are depended on by matched patches [DEFAULT]"]
tokens = GritArgOption [] ["token-chars"] Toks "\"[CHARS]\""
         "define token to contain these characters"

lazy :: GritOption
lazy = concat_options [__lazy, __ephemeral, __complete]

__lazy, __ephemeral, __complete :: GritOption
__lazy = GritNoArgOption [] ["lazy"] Lazy
              "get patch files only as needed"
__ephemeral = GritNoArgOption [] ["ephemeral"] Ephemeral
              "don't save patch files in the repository"
__complete = GritNoArgOption [] ["complete"] Complete
             "get a complete copy of the repository"
\end{code}

\begin{code}
force_replace = GritMultipleChoiceOption
                [GritNoArgOption ['f'] ["force"] ForceReplace
                 "proceed with replace even if 'new' token already exists",
                 GritNoArgOption [] ["no-force"]
                 NonForce "don't force the replace if it looks scary"]
\end{code}

\begin{code}
reply = GritArgOption [] ["reply"] Reply "FROM" "reply to email-based patch using FROM address"
apply_conflict_options
    = GritMultipleChoiceOption
      [GritNoArgOption [] ["mark-conflicts"]
       MarkConflicts "mark conflicts",
       GritNoArgOption [] ["allow-conflicts"]
       AllowConflicts "allow conflicts, but don't mark them",
       GritNoArgOption [] ["no-resolve-conflicts"] NoAllowConflicts
       "equivalent to --dont-allow-conflicts, for backwards compatibility",
       GritNoArgOption [] ["dont-allow-conflicts"]
       NoAllowConflicts "fail on patches that create conflicts [DEFAULT]"]
pull_conflict_options
    = GritMultipleChoiceOption
      [GritNoArgOption [] ["mark-conflicts"]
       MarkConflicts "mark conflicts [DEFAULT]",
       GritNoArgOption [] ["allow-conflicts"]
       AllowConflicts "allow conflicts, but don't mark them",
       GritNoArgOption [] ["dont-allow-conflicts"]
       NoAllowConflicts "fail on patches that create conflicts"]
use_external_merge = GritArgOption [] ["external-merge"]
                     ExternalMerge "COMMAND" "use external tool to merge conflicts"
\end{code}

\begin{options}
--dry-run
\end{options}
The \verb!--dry-run! option will cause darcs not to actually take the specified
action, but only print what would have happened.  Not all commands accept
\verb!--dry-run!, but those that do should accept the \verb!--summary!  option.

\begin{options}
--summary, --no-summary
\end{options}
The \verb!--summary! option shows a summary of the patches that would have been
pulled/pushed/whatever. The format is similar to the output format of
\verb!cvs update! and looks like this:

\begin{verbatim}
A  ./added_but_not_recorded.c
A! ./added_but_not_recorded_conflicts.c
a  ./would_be_added_if_look_for_adds_option_was_used.h

M  ./modified.t -1 +1
M! ./modified_conflicts.t -1 +1

R  ./removed_but_not_recorded.c
R! ./removed_but_not_recorded_conflicts.c

\end{verbatim}

You can probably guess what the flags mean from the clever file names.
\begin{description}
\item{\texttt{A}} is for files that have been added but not recorded yet.
\item{\texttt{a}} is for files found using the \verb!--look-for-adds! option available for
\verb!whatsnew! and \verb!record!. They have not been added yet, but would be
added automatically if \verb!--look-for-adds! were used with the next
\verb!record! command.

\item{\texttt{M}} is for files that have been modified in the working directory but not
recorded yet. The number of added and subtracted lines is also shown.

\item{\texttt{R}}  is for files that have been removed, but the removal is not
recorded yet.
\end{description}
An exclamation mark appears next to any option that has a conflict.

\begin{code}
noskip_boring = GritNoArgOption [] ["boring"]
                Boring "don't skip boring files"
allow_problematic_filenames = GritMultipleChoiceOption
                [GritNoArgOption [] ["case-ok"] AllowCaseOnly
                 "don't refuse to add files differing only in case"
                ,GritNoArgOption [] ["reserved-ok"] AllowWindowsReserved
                 "don't refuse to add files with Windows-reserved names"
                ]
diffflags = GritArgOption [] ["diff-opts"]
            DiffFlags "OPTIONS" "options to pass to diff"
\end{code}

\begin{code}
changes_format = GritMultipleChoiceOption
                 [human_readable,
                  GritNoArgOption [] ["number"] NumberPatches "number the changes",
                  GritNoArgOption [] ["count"] Count "output count of changes"
                 ]
changes_reverse = GritNoArgOption [] ["reverse"] Reverse
                  "show changes in reverse order"
show_autogenerated :: GritOption
show_autogenerated = GritMultipleChoiceOption
                     [GritNoArgOption [] ["show-autogenerated"] ShowAutogenerated
                                       "show autogenerated tags",
                      GritNoArgOption [] ["hide-autogenerated"] HideAutogenerated
                                           "hide autogenerated tags [default]"]

only_to_files :: GritOption
only_to_files = GritNoArgOption [] ["only-to-files"] OnlyChangesToFiles
                "show only changes to specified files"

human_readable = GritNoArgOption [] ["human-readable"]
                 HumanReadable "give human-readable output"
pipe = GritNoArgOption [] ["pipe"] Pipe "ask user interactively for the patch metadata"

interactive =
    GritNoArgOption ['i'] ["interactive"] Interactive
                         "prompt user interactively"
all_patches = GritNoArgOption ['a'] ["all"] All "answer yes to all patches"

all_interactive = GritMultipleChoiceOption [all_patches, interactive]

all_pipe_interactive
    = GritMultipleChoiceOption [all_patches,pipe,interactive]

pipe_interactive =
    GritMultipleChoiceOption [pipe, interactive]

repo_combinator =
    GritMultipleChoiceOption
    [GritNoArgOption [] ["intersection"] Intersection
     "take intersection of all repositories",
     GritNoArgOption [] ["union"] Union
     "take union of all repositories [DEFAULT]",
     GritNoArgOption [] ["complement"] Complement
     "take complement of repositories (in order listed)"]
\end{code}

\begin{code}
options_latex :: [GritOption] -> String
options_latex opts = "\\begin{tabular}{lll}\n"++
                     unlines (map option_latex opts)++
                     "\\end{tabular}\n"

latex_help :: String -> String
latex_help h
    = "\\begin{minipage}{7cm}\n\\raggedright\n" ++ h ++ "\\end{minipage}\n"

option_latex :: GritOption -> String
option_latex (GritNoArgOption a b _ h) =
    show_short_options a ++ show_long_options b ++ latex_help h ++ "\\\\"
option_latex (GritArgOption a b _ arg h) =
    show_short_options a ++
    show_long_options (map (++(" "++arg)) b) ++ latex_help h ++ "\\\\"
option_latex (GritAbsPathOrStdOption a b _ arg h) =
    show_short_options a ++
    show_long_options (map (++(" "++arg)) b) ++ latex_help h ++ "\\\\"
option_latex (GritAbsPathOption a b _ arg h) =
    show_short_options a ++
    show_long_options (map (++(" "++arg)) b) ++ latex_help h ++ "\\\\"
option_latex (GritOptAbsPathOption a b _ _ arg h) =
    show_short_options a ++
    show_long_options (map (++("[="++arg++"]")) b) ++ latex_help h ++ "\\\\"
option_latex (GritMultipleChoiceOption os) =
    unlines (map option_latex os)

show_short_options :: [Char] -> String
show_short_options [] = "&"
show_short_options [c] = "\\verb!-"++[c]++"! &"
show_short_options (c:cs) = "\\verb!-"++[c]++"!,"++show_short_options cs

show_long_options :: [String] -> String
show_long_options [] = " &"
show_long_options [s] = "\\verb!--" ++ s ++ "! &"
show_long_options (s:ss)
    = "\\verb!--" ++ s ++ "!,"++ show_long_options ss
\end{code}

\begin{code}
relink, sibling :: GritOption
relink = GritNoArgOption [] ["relink"] Relink
         "relink internal data to a sibling"

sibling = GritAbsPathOption [] ["sibling"] Sibling "URL"
          "specify a sibling directory"

-- | 'flagsToSiblings' collects the contents of all @Sibling@ flags in a list of flags.
flagsToSiblings :: [GritFlag] -> [AbsolutePath]
flagsToSiblings ((Sibling s) : l) = s : (flagsToSiblings l)
flagsToSiblings (_ : l) = flagsToSiblings l
flagsToSiblings [] = []
\end{code}

\begin{code}
nolinks :: GritOption
nolinks = GritNoArgOption [] ["nolinks"] NoLinks
          "do not link repository or pristine to sibling"
\end{code}

\begin{code}
reorder_patches :: GritOption
reorder_patches = GritNoArgOption [] ["reorder-patches"] Reorder
                  "reorder the patches in the repository"
\end{code}
\begin{options}
--sendmail-command
\end{options}

\label{env:SENDMAIL}

Several commands send email. The user can determine which mta to
use with the \verb!--sendmail-command! switch. For repetitive usage
of a specific sendmail command it is also possible to set the
environment variable \verb!SENDMAIL!. If there is no command line
switch given \verb!SENDMAIL! will be used if present.

\begin{code}
sendmail_cmd = GritArgOption [] ["sendmail-command"] SendmailCmd "COMMAND" "specify sendmail command"

-- |'get_sendmail_cmd' takes a list of flags and returns the sendmail command
-- to be used by @darcs send@. Looks for a command specified by
-- @SendmailCmd \"command\"@ in that list of flags, if any.
-- This flag is present if darcs was invoked with @--sendmail-command=COMMAND@
-- Alternatively the user can set @$SENDMAIL@ which will be used as a fallback if present.
get_sendmail_cmd :: [GritFlag] -> IO String 
get_sendmail_cmd (SendmailCmd a:_) = return a
get_sendmail_cmd (_:flags) = get_sendmail_cmd flags
get_sendmail_cmd [] = do easy_sendmail <- firstJustIO [ maybeGetEnv "SENDMAIL" ]
                         case easy_sendmail of
                            Just a -> return a
                            Nothing -> return ""
\end{code}

\begin{code}
files :: GritOption
files = GritMultipleChoiceOption
        [GritNoArgOption [] ["files"] Files
         "include files in output [DEFAULT]",
         GritNoArgOption [] ["no-files"] NoFiles
         "don't include files in output"]

directories :: GritOption
directories = GritMultipleChoiceOption
              [GritNoArgOption [] ["directories"] Directories
               "include directories in output [DEFAULT]",
               GritNoArgOption [] ["no-directories"] NoDirectories
               "don't include directories in output"]

pending :: GritOption
pending = GritMultipleChoiceOption
              [GritNoArgOption [] ["pending"] Pending
               "reflect pending patches in output [DEFAULT]",
               GritNoArgOption [] ["no-pending"] NoPending
               "only included recorded patches in output"]

nullFlag :: GritOption        -- "null" is already taken
nullFlag = GritNoArgOption ['0'] ["null"] NullFlag
       "separate file names by NUL characters"
\end{code}
\begin{options}
--posthook=COMMAND, --no-posthook
\end{options}
To provide a command that should be run whenever a darcs command completes
successfully, use \verb!--posthook! to specify the command.  This is useful
for people who want to have a command run whenever a patch is applied.  Using
\verb!--no-posthook! will disable running the command.

Some darcs commands export to the posthook command information about the
changes being made.  In particular, three environment variables are defined.
\verb!DARCS_PATCHES! contains a human-readable summary of the patches being
acted upon. The format is the same as "darcs changes".  \verb!DARCS_PATCHES_XML!
Contains the same details, in the same XML format as "darcs changes". Finally,
\verb!DARCS_FILES! contains a list of the files affected, one file per line.
If your repository has filenames including newlines, you'll just have to
cope.  Note, however, that \emph{none} of these environment variables are
defined when running under windows.  Note also that we refuse to pass
environment variables greater in size than 10k, in order to avoid triggering
\verb!E2BIG! errors.

\begin{code}

posthook_cmd :: GritOption
posthook_cmd = GritMultipleChoiceOption
               [GritArgOption [] ["posthook"] PosthookCmd
                "COMMAND" "specify command to run after this darcs command",
                GritNoArgOption [] ["no-posthook"] NoPosthook
                "don't run posthook command"]

-- | 'get_posthook_cmd' takes a list of flags and returns the posthook command
--  specified by @PosthookCmd a@ in that list of flags, if any.
get_posthook_cmd :: [GritFlag] -> Maybe String
get_posthook_cmd (PosthookCmd a:_) = Just a
get_posthook_cmd (_:flags) = get_posthook_cmd flags
get_posthook_cmd [] = Nothing
\end{code}
\begin{options}
--prehook=COMMAND, --no-prehook
\end{options}
To provide a command that should be run before a darcs command is executed,
 use \verb!--prehook! to specify the command.  An example use is
for people who want to have a command run whenever a patch is to be recorded, such as
translating line endings before recording patches.  Using
\verb!--no-prehook! will disable running the command.
\begin{code}
prehook_cmd :: GritOption
prehook_cmd = GritMultipleChoiceOption
               [GritArgOption [] ["prehook"] PrehookCmd
                "COMMAND" "specify command to run before this darcs command",
                GritNoArgOption [] ["no-prehook"] NoPrehook
                "don't run prehook command"]

-- | 'get_prehook_cmd' takes a list of flags and returns the prehook command
--  specified by @PrehookCmd a@ in that list of flags, if any.
get_prehook_cmd :: [GritFlag] -> Maybe String
get_prehook_cmd (PrehookCmd a:_) = Just a
get_prehook_cmd (_:flags) = get_prehook_cmd flags
get_prehook_cmd [] = Nothing
\end{code}

\begin{options}
--allow-unrelated-repos
\end{options}
By default darcs checks and warns user if repositories are unrelated when
doing pull, push and send. This option makes darcs skip this check.

\begin{code}
allow_unrelated_repos =
    GritNoArgOption [] ["ignore-unrelated-repos"] AllowUnrelatedRepos
                         "do not check if repositories are unrelated"
\end{code}

\begin{code}
-- | @'patch_select_flag' f@ holds whenever @f@ is a way of selecting
-- patches such as @PatchName n@.
patch_select_flag :: GritFlag -> Bool
patch_select_flag All = True
patch_select_flag (PatchName _) = True
patch_select_flag (OnePatch _) = True
patch_select_flag (SeveralPatch _) = True
patch_select_flag (AfterPatch _) = True
patch_select_flag (UpToPatch _) = True
patch_select_flag (TagName _) = True
patch_select_flag (LastN _) = True
patch_select_flag (OneTag _) = True
patch_select_flag (AfterTag _) = True
patch_select_flag (UpToTag _) = True
patch_select_flag _ = False
\end{code}
